<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste Debug - Editor 3D</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        #viewport { width: 800px; height: 600px; border: 2px solid #333; margin: 20px 0; }
        .debug-panel { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .log { background: #000; color: #0f0; padding: 10px; height: 200px; overflow-y: auto; font-family: monospace; }
    </style>
</head>
<body>
    <h1>üîç Teste Debug - Editor 3D</h1>
    
    <div class="debug-panel">
        <h3>Controles de Teste</h3>
        <button onclick="addTestBox()">Adicionar Cubo</button>
        <button onclick="addTestSphere()">Adicionar Esfera</button>
        <button onclick="clearScene()">Limpar Cena</button>
        <button onclick="logSceneInfo()">Log Info da Cena</button>
        <button onclick="testRender()">Testar Renderiza√ß√£o</button>
    </div>

    <div class="debug-panel">
        <h3>Configura√ß√µes</h3>
        <label>
            <input type="checkbox" id="auto-render" checked> Auto Render
        </label>
        <label>
            <input type="checkbox" id="debug-logs" checked> Debug Logs
        </label>
    </div>

    <div id="viewport"></div>
    
    <div class="debug-panel">
        <h3>Logs de Debug</h3>
        <div id="log" class="log"></div>
        <button onclick="clearLog()">Limpar Log</button>
    </div>

    <!-- Three.js -->
    <script src="../libs/three.min.js"></script>
    <script src="../libs/OrbitControls.js"></script>
    <script src="../libs/TransformControls.js"></script>

    <script>
        // Vari√°veis globais
        let scene, camera, renderer, controls, transformControls;
        let sceneHelpers;
        let testObjects = [];

        // Sistema de logs
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#f00' : type === 'success' ? '#0f0' : '#0ff';
            logDiv.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // Inicializa√ß√£o
        function init() {
            log('üöÄ Inicializando teste debug...');
            
            try {
                // Cena
                scene = new THREE.Scene();
                sceneHelpers = new THREE.Scene();
                log('‚úÖ Cenas criadas');

                // C√¢mera
                const container = document.getElementById('viewport');
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 0, 0);
                log('‚úÖ C√¢mera criada - Posi√ß√£o:', camera.position);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);
                log('‚úÖ Renderer criado - Tamanho:', container.clientWidth, 'x', container.clientHeight);

                // Controles
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                log('‚úÖ OrbitControls criado');

                // TransformControls
                transformControls = new THREE.TransformControls(camera, renderer.domElement);
                transformControls.visible = true;
                sceneHelpers.add(transformControls.getHelper());
                log('‚úÖ TransformControls criado');

                // Ilumina√ß√£o
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                log('‚úÖ Ilumina√ß√£o configurada');

                // Grid
                const gridHelper = new THREE.GridHelper(20, 20);
                sceneHelpers.add(gridHelper);
                
                const axesHelper = new THREE.AxesHelper(5);
                sceneHelpers.add(axesHelper);
                log('‚úÖ Helpers adicionados');

                // Loop de renderiza√ß√£o
                animate();
                log('‚úÖ Loop de anima√ß√£o iniciado');

                log('üéâ Inicializa√ß√£o completa!', 'success');

            } catch (error) {
                log('‚ùå Erro na inicializa√ß√£o: ' + error.message, 'error');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            render();
        }

        function render() {
            renderer.clear();
            renderer.render(scene, camera);
            renderer.render(sceneHelpers, camera);
        }

        function addTestBox() {
            log('üì¶ Adicionando cubo de teste...');
            
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(0, 0, 0);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            testObjects.push(mesh);
            
            log('‚úÖ Cubo adicionado - Posi√ß√£o:', mesh.position);
            log('üìä Total de objetos na cena:', scene.children.length);
            
            if (document.getElementById('auto-render').checked) {
                render();
                log('üé® Renderiza√ß√£o executada');
            }
        }

        function addTestSphere() {
            log('üî¥ Adicionando esfera de teste...');
            
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(2, 0, 0);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            testObjects.push(mesh);
            
            log('‚úÖ Esfera adicionada - Posi√ß√£o:', mesh.position);
            log('üìä Total de objetos na cena:', scene.children.length);
            
            if (document.getElementById('auto-render').checked) {
                render();
                log('üé® Renderiza√ß√£o executada');
            }
        }

        function clearScene() {
            log('üßπ Limpando cena...');
            
            testObjects.forEach(obj => {
                scene.remove(obj);
            });
            testObjects = [];
            
            log('‚úÖ Cena limpa - Objetos restantes:', scene.children.length);
            
            if (document.getElementById('auto-render').checked) {
                render();
                log('üé® Renderiza√ß√£o executada');
            }
        }

        function logSceneInfo() {
            log('üìä === INFORMA√á√ïES DA CENA ===');
            log('C√¢mera posi√ß√£o:', camera.position);
            log('C√¢mera rota√ß√£o:', camera.rotation);
            log('C√¢mera FOV:', camera.fov);
            log('C√¢mera aspect:', camera.aspect);
            log('C√¢mera near:', camera.near);
            log('C√¢mera far:', camera.far);
            log('Renderer tamanho:', renderer.getSize(new THREE.Vector2()));
            log('Scene children:', scene.children.length);
            log('SceneHelpers children:', sceneHelpers.children.length);
            
            scene.children.forEach((child, index) => {
                if (child.isMesh) {
                    log(`Objeto ${index}: ${child.type} - Posi√ß√£o: ${child.position.x.toFixed(2)}, ${child.position.y.toFixed(2)}, ${child.position.z.toFixed(2)} - Vis√≠vel: ${child.visible}`);
                }
            });
            
            log('TransformControls vis√≠vel:', transformControls.visible);
            log('TransformControls objeto:', transformControls.object ? transformControls.object.type : 'Nenhum');
            log('TransformControls modo:', transformControls.mode);
        }

        function testRender() {
            log('üé® Testando renderiza√ß√£o manual...');
            render();
            log('‚úÖ Renderiza√ß√£o manual executada');
        }

        // Inicializar quando a p√°gina carregar
        window.addEventListener('load', init);
    </script>
</body>
</html>
